var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var retinaJs;
(function (retinaJs) {
    // Hi, here is Retina tyles
    (function (mediaChannelType) {
        mediaChannelType[mediaChannelType["Camera"] = 0] = "Camera";
        mediaChannelType[mediaChannelType["FileUpload"] = 1] = "FileUpload";
    })(retinaJs.mediaChannelType || (retinaJs.mediaChannelType = {}));
    var mediaChannelType = retinaJs.mediaChannelType;
    (function (WebcamRequiredAction) {
        WebcamRequiredAction[WebcamRequiredAction["StopCapturing"] = 1] = "StopCapturing";
        WebcamRequiredAction[WebcamRequiredAction["PauseCapturing"] = 2] = "PauseCapturing";
        WebcamRequiredAction[WebcamRequiredAction["KeepCapturing"] = 3] = "KeepCapturing";
    })(retinaJs.WebcamRequiredAction || (retinaJs.WebcamRequiredAction = {}));
    var WebcamRequiredAction = retinaJs.WebcamRequiredAction;
    (function (StillImageRequiredAction) {
        StillImageRequiredAction[StillImageRequiredAction["KeepCapturing"] = 1] = "KeepCapturing";
        StillImageRequiredAction[StillImageRequiredAction["StopCapturing"] = 2] = "StopCapturing";
        StillImageRequiredAction[StillImageRequiredAction["ManualCroppingRequired"] = 3] = "ManualCroppingRequired";
    })(retinaJs.StillImageRequiredAction || (retinaJs.StillImageRequiredAction = {}));
    var StillImageRequiredAction = retinaJs.StillImageRequiredAction;
    (function (MediaType) {
        MediaType[MediaType["WhiteImage"] = 1] = "WhiteImage";
        MediaType[MediaType["UltravioletAImage"] = 2] = "UltravioletAImage";
        MediaType[MediaType["UltravioletBImage"] = 2] = "UltravioletBImage";
        MediaType[MediaType["InfraredImage"] = 3] = "InfraredImage";
        MediaType[MediaType["RFIDPhoto"] = 4] = "RFIDPhoto";
        MediaType[MediaType["RFIDMrz"] = 5] = "RFIDMrz";
        MediaType[MediaType["RFIDRawData"] = 6] = "RFIDRawData";
        MediaType[MediaType["FacePhoto"] = 7] = "FacePhoto";
        MediaType[MediaType["VideoStream"] = 9] = "VideoStream";
        MediaType[MediaType["HologramFootage"] = 11] = "HologramFootage";
        MediaType[MediaType["FingerPrint"] = 15] = "FingerPrint";
    })(retinaJs.MediaType || (retinaJs.MediaType = {}));
    var MediaType = retinaJs.MediaType;
    (function (MediaSource) {
        MediaSource[MediaSource["Undetermined"] = 0] = "Undetermined";
        MediaSource[MediaSource["PassportScanner"] = 1] = "PassportScanner";
        MediaSource[MediaSource["A4Scanner"] = 2] = "A4Scanner";
        MediaSource[MediaSource["Webcam"] = 3] = "Webcam";
        MediaSource[MediaSource["MobileCam"] = 4] = "MobileCam";
        MediaSource[MediaSource["IDScanImageCaptureService"] = 5] = "IDScanImageCaptureService";
    })(retinaJs.MediaSource || (retinaJs.MediaSource = {}));
    var MediaSource = retinaJs.MediaSource;
})(retinaJs || (retinaJs = {}));
var retinaJs;
(function (retinaJs) {
    var helper = (function () {
        function helper() {
        }
        helper.extend = function (target, settings) {
            target = target || {};
            for (var prop in settings) {
                if (typeof settings[prop] === 'object') {
                    target[prop] = helper.extend(target[prop], settings[prop]);
                }
                else {
                    target[prop] = settings[prop];
                }
            }
            return target;
        };
        helper.defaultRetinaSettings = {
            cortexApiPath: 'http://localhost/VisionCortex/',
            autoRun: false
        };
        return helper;
    }());
    retinaJs.helper = helper;
})(retinaJs || (retinaJs = {}));
var retinaJs;
(function (retinaJs) {
    var Subscription = (function () {
        function Subscription(id, callback) {
            this.id = id;
            this.callback = callback;
        }
        return Subscription;
    }());
    var Message = (function () {
        function Message(message) {
            this.message = message;
            this._subscriptions = [];
            this._nextId = 0;
        }
        Message.prototype.subscribe = function (callback) {
            var subscription = new Subscription(this._nextId++, callback);
            this._subscriptions[subscription.id] = subscription;
            return subscription.id;
        };
        Message.prototype.unSubscribe = function (id) {
            this._subscriptions[id] = undefined;
        };
        Message.prototype.notify = function (payload) {
            var index;
            for (index = 0; index < this._subscriptions.length; index++) {
                if (this._subscriptions[index]) {
                    this._subscriptions[index].callback(payload);
                }
            }
        };
        return Message;
    }());
    var eventManager = (function () {
        function eventManager() {
        }
        eventManager.createMessagesArray = function () {
            return {};
        };
        return eventManager;
    }());
    retinaJs.eventManager = eventManager;
    var subscriber = (function () {
        function subscriber(_messages) {
            this._messages = _messages;
        }
        subscriber.prototype.subscribe = function (message, callback) {
            var msg;
            msg = this._messages[message] ||
                (this._messages[message] = new Message(message));
            return msg.subscribe(callback);
        };
        subscriber.prototype.unSubscribe = function (message, subscriptionId) {
            if (this._messages[message]) {
                (this._messages[message]).unSubscribe(subscriptionId);
            }
        };
        return subscriber;
    }());
    retinaJs.subscriber = subscriber;
    var publisher = (function () {
        function publisher(_messages) {
            this._messages = _messages;
        }
        publisher.prototype.publish = function (message, payload) {
            if (this._messages[message]) {
                (this._messages[message]).notify(payload);
            }
        };
        return publisher;
    }());
    retinaJs.publisher = publisher;
})(retinaJs || (retinaJs = {}));
/// <reference path="types.ts" />
var retinaJs;
(function (retinaJs) {
    var baseImageCaptureService = (function () {
        function baseImageCaptureService(journeyId, mediaType) {
            console.log('** baseImageCaptureService | constructor **');
            this._mediaType = mediaType;
            this.journeyId = journeyId;
        }
        Object.defineProperty(baseImageCaptureService.prototype, "channelType", {
            get: function () {
                return retinaJs.mediaChannelType[this._mediaType];
            },
            enumerable: true,
            configurable: true
        });
        baseImageCaptureService.prototype.initalizeCaptureSession = function (options, isMediacreated) {
            if (isMediacreated === void 0) { isMediacreated = false; }
            console.log('** baseImageCaptureService | initalizeCaptureSession **');
            console.log('Current IMediaChannelOptions: ', options);
            this.sendMedia(options, isMediacreated);
        };
        baseImageCaptureService.prototype.finish = function (keepMedia) {
            // ToDo: implement later
            console.log('you are calling the base "end()" method ');
        };
        ;
        baseImageCaptureService.prototype.start = function () {
            // ToDo: implement later
            console.log('you are calling the base "run()" method ');
        };
        ;
        baseImageCaptureService.prototype.subscribe = function (message, callback) {
            // ToDo: implement later
            console.log('you are calling the base "subscribe()" method ');
        };
        ;
        baseImageCaptureService.prototype.unSubscribe = function (message, subscriptionId) {
            // ToDo: implement later
            console.log('you are calling the base "unSubscribe()" method ');
        };
        ;
        baseImageCaptureService.prototype.runTestResponse = function (response) {
        };
        return baseImageCaptureService;
    }());
    retinaJs.baseImageCaptureService = baseImageCaptureService;
})(retinaJs || (retinaJs = {}));
/// <reference path="../../../typings/index.d.ts" />
var retinaJs;
(function (retinaJs) {
    var httpRequestService = (function () {
        function httpRequestService() {
        }
        httpRequestService.JQueryAjax = function (ajaxSettings) {
            if (ajaxSettings.headers === undefined || ajaxSettings.headers === null)
                ajaxSettings.headers = {
                    'Authorization': 'Bearer ' + this.authenticationToken
                };
            else
                ajaxSettings.headers['Authorization'] = 'Bearer ' + this.authenticationToken;
            return $.ajax(ajaxSettings);
        };
        httpRequestService.authenticationToken = undefined;
        return httpRequestService;
    }());
    retinaJs.httpRequestService = httpRequestService;
})(retinaJs || (retinaJs = {}));
/// <reference path="httpRequestService.ts" />
var retinaJs;
(function (retinaJs) {
    var factory = (function () {
        function factory() {
        }
        factory.create = function (journeyId, containerId, authenticationToken, apiCaptureChannelConfiguration, retinaSettings) {
            var self = this;
            self.deferred = $.Deferred();
            console.group(' factory - create');
            retinaJs.httpRequestService.authenticationToken = authenticationToken;
            self.currentRetinaService = new retinaJs.retinaService(journeyId, containerId, apiCaptureChannelConfiguration, retinaSettings);
            self.currentRetinaService.reset(journeyId).then(function () {
                self.deferred.resolve(self.currentRetinaService);
            });
            console.groupEnd(); // factory - create
            return this.deferred.promise();
        };
        factory.deferred = undefined;
        factory.currentRetinaService = undefined;
        return factory;
    }());
    retinaJs.factory = factory;
})(retinaJs || (retinaJs = {}));
var retinaJs;
(function (retinaJs) {
    var webCam;
    (function (webCam) {
        var helper = (function () {
            function helper() {
            }
            helper.isValiedIntNumber = function (param) {
                return (this.isDefined(param) && isFinite(param) && isFinite(parseInt(param)) && this.isNumber(parseInt(param)));
            };
            helper.isValiedFloatNumber = function (param) {
                return (this.isDefined(param) && isFinite(param) && isFinite(parseFloat(param)) && this.isNumber(parseFloat(param)));
            };
            helper.isNumber = function (value) { return typeof value === 'number'; };
            helper.isDefined = function (value) { return typeof value !== 'undefined'; };
            helper.newGuid = function () {
                function s4() {
                    return Math.floor((1 + Math.random()) * 0x10000)
                        .toString(16)
                        .substring(1);
                }
                return s4() + s4() + '-' + s4() + '-' + s4() + '-' +
                    s4() + '-' + s4() + s4() + s4();
            };
            helper.getCurrentTime = function () {
                var date = new Date();
                var currentTime = date.getHours() + ':' + date.getMinutes() + ':' + date.getSeconds() + ':' + date.getMilliseconds();
                return currentTime;
            };
            helper.mediaDevicesimplementationForOlderBrowsers = function () {
                // Older browsers might not implement mediaDevices at all, so we set an empty object first
                if (navigator.mediaDevices === undefined) {
                    navigator.mediaDevices = {};
                }
                // Some browsers partially implement mediaDevices. We can't just assign an object
                // with getUserMedia as it would overwrite existing properties.
                // Here, we will just add the getUserMedia property if it's missing.
                if (navigator.mediaDevices.getUserMedia === undefined) {
                    navigator.mediaDevices.getUserMedia = function (constraints) {
                        // First get ahold of the legacy getUserMedia, if present
                        // var getUserMedia = navigator.webkitGetUserMedia || navigator.mozGetUserMedia;
                        var getUserMedia = (navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia);
                        // Some browsers just don't implement it - return a rejected promise with an error
                        // to keep a consistent interface
                        if (!getUserMedia) {
                            return Promise.reject(new Error('getUserMedia is not implemented in this browser'));
                        }
                        // Otherwise, wrap the call to the old navigator.getUserMedia with a Promise
                        return new Promise(function (resolve, reject) {
                            getUserMedia.call(navigator, constraints, resolve, reject);
                        });
                    };
                }
            };
            helper.setWebSocketPort = function (path) {
                var temp = path;
                if (path.endsWith('/'))
                    temp = path.slice(0, path.length - 1);
                var base = temp.split(':')[0];
                base += ":8088/";
                return base;
            };
            //#region Autocapture check private methods
            helper.checkCameraCompatiblity = function () {
                var area = 'camera media channel: ';
                //Check canvas support
                if (!this.isCanvasSupported()) {
                    throw new Error(area + ' Canvas is not supported or at least getContext("2d") is not.');
                }
                //Check toBolb functionality
                if (!this.isBolbSupported()) {
                    throw new Error(area + 'toBolb is not supported.');
                }
                //Check Websockets capability
                if (!this.isWebsocketsSupported()) {
                    throw new Error(area + 'Websockets is not supported in the current browser.');
                }
                return true;
            };
            helper.isCanvasSupported = function () {
                var elem = document.createElement('canvas');
                return !!(elem.getContext && elem.getContext('2d'));
            };
            helper.isBolbSupported = function () {
                var canvasPrototype = HTMLCanvasElement && HTMLCanvasElement.prototype;
                if (!HTMLCanvasElement || !canvasPrototype.toBlob) {
                    // $log.info(area + ' no getUserMedia object of any kind !');
                    return false;
                }
                return true;
            };
            helper.isWebsocketsSupported = function () {
                return "WebSocket" in window || "MozWebSocket" in window;
            };
            // https://webrtc.github.io/samples/src/content/getusermedia/resolution/
            helper.qvgaVideoConstraints = {
                video: { width: { exact: 320 }, height: { exact: 240 } },
                audio: false
            };
            helper.vgaVideoConstraints = {
                video: { width: { exact: 640 }, height: { exact: 480 } },
                audio: false
            };
            helper.hdVideoConstraints = {
                video: { width: { exact: 1280 }, height: { exact: 720 } },
                audio: false
            };
            helper.fullHdVideoConstraints = {
                video: { width: { exact: 1920 }, height: { exact: 1080 } },
                audio: false
            };
            helper.constraintsArr = new Array(
            // helper.fullHdVideoConstraints,
            //  helper.hdVideoConstraints,
            helper.vgaVideoConstraints);
            return helper;
        }());
        webCam.helper = helper;
    })(webCam = retinaJs.webCam || (retinaJs.webCam = {}));
})(retinaJs || (retinaJs = {}));
/// <reference path="helper.ts" />
/// <reference path="../../types.ts" />
/// <reference path="../../eventManager.ts" />
/// <reference path="../../httpRequestService.ts" />
var retinaJs;
(function (retinaJs) {
    var webCam;
    (function (webCam) {
        // This service keeps track of pending requests
        var sendingFramesManager = (function () {
            function sendingFramesManager(journeyId, cortexApiPath, publisher) {
                this._stepNumber = 1;
                this.publisher = publisher;
                // cortexApiPath come like this : //t3.localhost/ApplicationAPI/
                var port = cortexApiPath.split(':')[1].split('/')[0];
                var prefix = (port == '80') ? 'ws:' : 'wss:';
                var cameraApiController = 'LivenessStreamingSocket';
                // let params = `?journeyId=${journeyId}&stepNumber=${stepNumber}`;
                this.journeyId = journeyId;
                //cortexApiPath = '//t3.localhost:8088/';
                var webSocketPath = cortexApiPath; //  helper.setWebSocketPort(cortexApiPath);
                this.host = prefix + webSocketPath + cameraApiController;
            }
            Object.defineProperty(sendingFramesManager.prototype, "stepNumber", {
                get: function () {
                    return this._stepNumber++;
                },
                enumerable: true,
                configurable: true
            });
            sendingFramesManager.prototype.setResponseHandler = function (self, handler) {
                this.handler = handler;
                this.self = self;
            };
            sendingFramesManager.prototype.connect = function () {
                var params = "?journeyId=" + this.journeyId + "&stepNumber=" + this.stepNumber + " ";
                params += "&authenticationToken=" + retinaJs.httpRequestService.authenticationToken + " ";
                // let wsImpl = window.WebSocket || window.MozWebSocket;
                return new Promise(function (resolve, reject) {
                    try {
                        var self = this;
                        this.socket = new WebSocket(this.host + params);
                        this.socket.onopen = function (openEvent) {
                            console.log('WebSocket Status: Socket Open');
                            resolve('WebSocket is openned successfully');
                        };
                        this.socket.onerror = function (errorEvent) {
                            console.log('WebSocket Status: Error was reported');
                            reject(errorEvent);
                            // throw new Error('WebSocket: can not establish connection to the server');
                        };
                        this.socket.onmessage = function (messageEvent) {
                            console.log('WebSocket Status: Socket message recieved ', messageEvent);
                            if (messageEvent.data) {
                                console.log(messageEvent.data);
                                var data = JSON.parse(messageEvent.data);
                                self.captureResponse(self, data);
                            }
                        };
                        this.socket.onclose = function (closeEvent) {
                            console.log('WebSocket Status: Socket Closed');
                            console.log(closeEvent);
                        };
                    }
                    catch (exception) {
                        console.log('camera media channel: can not establish connection to the server: ' + this.host);
                        console.log(exception);
                        reject(exception.message);
                    }
                }.bind(this));
            };
            sendingFramesManager.prototype.send = function (data, done) {
                if (this.socket !== undefined && this.socket.readyState == WebSocket.OPEN)
                    this.socket.send(data);
            };
            sendingFramesManager.prototype.captureResponse = function (self, response) {
                // publish new message
                switch (response.requiredAction) {
                    case 'PauseCapturing':
                        this.publisher.publish('additionalStepRequired', response);
                        break;
                    case 'StopCapturing':
                        this.publisher.publish('captureSessionFinished', response);
                        break;
                    case 'KeepCapturing':
                        this.publisher.publish('notificationMessage', response);
                        break;
                }
                console.log('new push coming from the Server', response);
                // response.message += helper.getCurrentTime();
                this.handler(this.self, response);
            };
            sendingFramesManager.prototype.close = function () {
                if (this.socket !== undefined && this.socket.readyState !== WebSocket.CLOSED)
                    this.socket.close();
            };
            sendingFramesManager.prototype.runTestResponse = function (response) {
                this.captureResponse(this, response);
            };
            return sendingFramesManager;
        }());
        webCam.sendingFramesManager = sendingFramesManager;
    })(webCam = retinaJs.webCam || (retinaJs.webCam = {}));
})(retinaJs || (retinaJs = {}));
/// <reference path="helper.ts" />
/// <reference path="sendingFramesManager.ts" />
/// <reference path="../../types.ts" />
/// <reference path="../../../../../typings/index.d.ts" />
var retinaJs;
(function (retinaJs) {
    var webCam;
    (function (webCam) {
        var cameraCapture = (function () {
            //#endregion
            function cameraCapture(options, journeyId, isMediacreated) {
                if (isMediacreated === void 0) { isMediacreated = false; }
                // public commonInformation: any;
                this.template = "<div id=\"autoCaptureContainer\">\n                <div id=\"camera-notification\" class=\"hidden\">\n                    <span id=\"messageContainer\" class=\"hidden\"></span>\n                    <span id=\"timeCounterContainer\" class=\"hidden\"></span>\n                </div>\n                <figure id=\"videoContainer\" data-fullscreen=\"false\">\n                    <video id=\"autoCaptureVideo\" playsinline autoplay style=\"-moz-transform: scale(-1, 1);\n                    -webkit-transform: scale(-1, 1); -o-transform: scale(-1, 1);\n                    transform: scale(-1, 1); filter: FlipH;margin-bottom: 15px;\"></video>\n                </figure>\n                <canvas style=\"visibility:collapse;width:0px;\" id=\"autoCaptureCanvas\" />\n            </div>";
                this.isMediacreated = false;
                console.log('** cameraCapture | constructor **');
                this.isMediacreated = isMediacreated;
                // check if it's possible to deal with camera, if it's NOT an exception will be thrown
                if (!this.isMediacreated)
                    webCam.helper.checkCameraCompatiblity();
                console.log('checkCameraCompatiblity went well ');
                this.options = options;
                this.journeyId = journeyId;
                this.setDefaultValues();
                if (!this.isMediacreated) {
                    this.injectCameraHtml();
                }
                else {
                    this.cleanHtmlContent();
                }
                this.assignCameraElementsRefs();
            }
            cameraCapture.prototype.init = function () {
                return new Promise(function (resolve, reject) {
                    this.createSendingFramesService()
                        .then(function () {
                        if (!this.isMediacreated)
                            return this.activateUserMedia(this.constraints);
                        else
                            return Promise.resolve();
                    }.bind(this))
                        .then(function () { resolve(true); })
                        .catch(function () { reject(false); });
                }.bind(this));
            };
            //#region public methods
            cameraCapture.prototype.setDefaultValues = function () {
                console.log('setDefaultValues');
                this.containerId = this.options.containerId;
                this.cortexApiPath = this.options.cortexApiPath;
                // this.commonInformation = this.options.commonInformation !== undefined ? this.options.commonInformation : {};
                this.imageQuality = 0.85;
                if (this.options.imageQuality !== undefined && webCam.helper.isValiedIntNumber(this.options.imageQuality)) {
                    var imageQualityPassed = this.options.imageQuality / 100;
                    if (imageQualityPassed <= 1 && imageQualityPassed > 0) {
                        this.imageQuality = imageQualityPassed;
                    }
                }
                this.currentConstraintIndex = 0;
                this.constraints = webCam.helper.constraintsArr[this.currentConstraintIndex++];
                this.isCameraRun = false;
                this.capturingTimer = undefined;
                //this.pauseCapturingTimer = undefined;
                this.sendingFramesTimer = undefined;
                // this.pauseSendingFramesTimer = undefined;
                this.pauseTimer = undefined;
                this.reconnectTimer = undefined;
                this.downCounterTimer = undefined;
                // this.metadata = [];
                this.isUserMediaNotConnected = false;
                this.operationId = 1;
                this.stopCapturing = false;
                this.SENDING_REQUESTS_DELAY_MILLISECOND = 30;
                this.CAPTURING_DELAY_MILLISECOND = 30;
                this.MAX_CONCURRENT_REQUESTS = 5;
                this.MAX_AVAILABLE_CAPTURED_IMAGES_COUNT = 5;
                this.SEND_REQUEST_TIMEOUT_SECOND = 0.2; // 0.500;  //$filter('date')(new Date().setTime(500), 'ss:sss');
                if (this.options.frameSubmitionDelay !== undefined && webCam.helper.isValiedFloatNumber(this.options.frameSubmitionDelay)) {
                    var frameSubmitionDelay = this.options.frameSubmitionDelay;
                    //if (frameSubmitionDelay <= 1 && frameSubmitionDelay >= 0) {
                    this.SEND_REQUEST_TIMEOUT_SECOND = frameSubmitionDelay;
                }
                this.capturedImagesQueue = [];
                this.lastSentRequestTime = new Date().getTime();
                // create message array and assign it to both publisher and subscriber
                this.eventsMessagesContainer = retinaJs.eventManager.createMessagesArray();
                this.publisher = new retinaJs.publisher(this.eventsMessagesContainer);
                this.subscriber = new retinaJs.subscriber(this.eventsMessagesContainer);
            };
            cameraCapture.prototype.createSendingFramesService = function () {
                this.sendingFramesService = new webCam.sendingFramesManager(this.journeyId, this.cortexApiPath, this.publisher);
                this.sendingFramesService.setResponseHandler(this, this.handleResponse);
                return this.sendingFramesService.connect();
            };
            cameraCapture.prototype.start = function () {
                if (this.isCameraRun) {
                    console.log('The camera is already runs');
                    return;
                }
                this.isCameraRun = true;
                this.startCapturingTimer(this);
                this.startSendingFramesTimer(this);
            };
            cameraCapture.prototype.finish = function (keepMedia) {
                if (keepMedia === undefined || keepMedia === false) {
                    console.log('Camera is removing from layout...');
                    this.stopStreaming();
                }
                this.stopPausingTimers(this);
                this.stopCapturingTimer();
                this.stopSendingFramesTimer();
                this.sendingFramesService.close();
            };
            cameraCapture.prototype.subscribe = function (message, callback) {
                return this.subscriber.subscribe(message, callback);
            };
            cameraCapture.prototype.unSubscribe = function (message, subscriptionId) {
                this.subscriber.unSubscribe(message, subscriptionId);
            };
            cameraCapture.prototype.runTestResponse = function (response) {
                this.sendingFramesService.runTestResponse(response);
            };
            //#endregion
            //#region private methods
            cameraCapture.prototype.injectCameraHtml = function () {
                console.log('injectCameraHtml');
                document.getElementById(this.containerId).innerHTML = this.template;
            };
            cameraCapture.prototype.assignCameraElementsRefs = function () {
                this.autoCaptureContainer = document.getElementById('autoCaptureContainer');
                this.autoCaptureVideo = document.getElementById('autoCaptureVideo');
                this.autoCaptureCanvas = document.getElementById('autoCaptureCanvas');
            };
            cameraCapture.prototype.cleanHtmlContent = function () {
                var cameraNotification = document.getElementById('camera-notification');
                var messageContainer = document.getElementById('messageContainer');
                var timeCounterContainer = document.getElementById('timeCounterContainer');
                messageContainer.innerHTML = '';
                timeCounterContainer.innerHTML = '';
                cameraNotification.setAttribute('class', 'hidden');
                messageContainer.setAttribute('class', 'hidden');
                timeCounterContainer.setAttribute('class', 'hidden');
            };
            //#region Prepare User Media   
            cameraCapture.prototype.activateUserMedia = function (constraints) {
                var self = this;
                console.log('currentConstraintIndex is :', self.currentConstraintIndex - 1);
                console.log('currentConstraintIndex constraints :', constraints.video);
                webCam.helper.mediaDevicesimplementationForOlderBrowsers();
                return navigator.mediaDevices.getUserMedia(constraints).then(function (stream) {
                    /* use the stream */
                    return self.activateUserMediaSuccess(stream, self);
                }).catch(function (err) {
                    /* handle the error */
                    console.log('activateUserMediaError ', err);
                    if (self.currentConstraintIndex === webCam.helper.constraintsArr.length) {
                        self.isUserMediaNotConnected = true;
                        return Promise.reject(err);
                    }
                    else {
                        return self.activateUserMedia(webCam.helper.constraintsArr[self.currentConstraintIndex++]);
                    }
                });
            };
            cameraCapture.prototype.activateUserMediaSuccess = function (stream, self) {
                self.isUserMediaNotConnected = false;
                if (!self.isMediacreated) {
                    self.autoCaptureVideo.addEventListener('resize', function () { self.videoResizeEventListener(self); });
                    self.autoCaptureVideo.srcObject = stream;
                }
                cameraCapture.strm = stream;
                return Promise.resolve(stream);
            };
            cameraCapture.prototype.videoResizeEventListener = function (self) {
                self.autoCaptureCanvas.width = self.autoCaptureVideo.videoWidth;
                self.autoCaptureCanvas.height = self.autoCaptureVideo.videoHeight;
            };
            //#endregion
            //#region capturingTimer
            cameraCapture.prototype.startCapturingTimer = function (self) {
                // Don't start Capturing new image  if we are already sent
                if (webCam.helper.isDefined(self.capturingTimer)) {
                    return;
                }
                console.log('startCapturingTimer');
                self.capturingTimer = setInterval(function () {
                    self.captureAndAddToCapturedImagesQueue(self);
                }, self.CAPTURING_DELAY_MILLISECOND);
            };
            cameraCapture.prototype.captureAndAddToCapturedImagesQueue = function (self) {
                if (self.capturedImagesQueue.length >= self.MAX_AVAILABLE_CAPTURED_IMAGES_COUNT) {
                    //remove first one in the queue
                    self.capturedImagesQueue.shift();
                }
                //  cameraCapture.start = new Date().getTime();
                self.convertToGrayscale(self);
                //  self.autoCaptureCanvas.getContext('2d').drawImage(self.autoCaptureVideo, 0, 0);
                self.autoCaptureCanvas.toBlob(function (blb) {
                    self.toBlobCallback(blb, self);
                }, 'image/jpeg', self.imageQuality);
            };
            cameraCapture.prototype.convertToGrayscale = function (self) {
                var context = self.autoCaptureCanvas.getContext('2d');
                context.drawImage(self.autoCaptureVideo, 0, 0);
                var imageData = context.getImageData(0, 0, self.autoCaptureCanvas.width, self.autoCaptureCanvas.height);
                var data = imageData.data;
                for (var i = 0; i < data.length; i += 4) {
                    var brightness = 0.34 * data[i] + 0.5 * data[i + 1] + 0.16 * data[i + 2];
                    // red
                    data[i] = brightness;
                    // green
                    data[i + 1] = brightness;
                    // blue
                    data[i + 2] = brightness;
                }
                // overwrite original image
                context.putImageData(imageData, 0, 0);
            };
            cameraCapture.prototype.toBlobCallback = function (blb, self) {
                //   cameraCapture.long = new Date().getTime() - cameraCapture.start;
                //  var cameraCaptureFormated = cameraCapture.long / 1000; // $filter('date')(delayToComplete, 'ss:sss');
                //    console.log('cameraCaptureFormated ', cameraCaptureFormated);
                //    var formData = new FormData();
                //    formData.append('image-filename', (new Date()).getTime() + 'CapturedFrame.jpg');
                //    formData.append('image-blob', blb);
                //   self.addCommonRequestParameters(formData);
                //   self.capturedImagesQueue.push(formData);
                self.capturedImagesQueue.push(blb);
            };
            cameraCapture.prototype.stopCapturingTimer = function () {
                if (webCam.helper.isDefined(this.capturingTimer)) {
                    console.log('stopCapturingTimer');
                    clearInterval(this.capturingTimer);
                    this.capturingTimer = undefined;
                    this.stopCapturing = true;
                    // delete array items
                    this.capturedImagesQueue.length = 0;
                }
            };
            //#endregion
            //#region SendingFramesTimer
            cameraCapture.prototype.startSendingFramesTimer = function (self) {
                if (webCam.helper.isDefined(self.sendingFramesTimer))
                    return;
                console.log('startSendingFramesTimer');
                this.stopCapturing = false;
                self.sendingFramesTimer = setInterval(function () {
                    if (!self.stopCapturing) {
                        /**
                         * This code is to apply a delay time between sending frames
                         * for example send new frame after minimum 0.5 second
                         * if SEND_REQUEST_TIMEOUT_SECOND variable is set to 0 then frames will be sent without any delay
                         */
                        // here format delayToComplete to be in seconds:
                        var delayToComplete = new Date().getTime() - self.lastSentRequestTime;
                        var delayToCompleteFormated = delayToComplete / 1000;
                        if (delayToCompleteFormated >= self.SEND_REQUEST_TIMEOUT_SECOND)
                            self.sendNewFrame();
                    }
                }, self.SENDING_REQUESTS_DELAY_MILLISECOND);
            };
            cameraCapture.prototype.stopSendingFramesTimer = function () {
                if (webCam.helper.isDefined(this.sendingFramesTimer)) {
                    console.log('stopSendingFramesTimer ');
                    clearInterval(this.sendingFramesTimer);
                    this.sendingFramesTimer = undefined;
                    this.stopCapturing = true;
                }
            };
            cameraCapture.prototype.pauseCaturing = function (pauseDuration) {
                console.log('we are in pauseCaturing for ', pauseDuration, ' seconds');
                var self = this;
                this.showDownCounter(self, pauseDuration);
                pauseDuration += 2;
                this.stopPausingTimers(this);
                this.stopSendingFramesTimer();
                this.stopCapturingTimer();
                this.sendingFramesService.close();
                self.pauseTimer = setTimeout(function () {
                    this.sendingFramesService.connect().then(function () {
                        this.startSendingFramesTimer(this);
                        this.startCapturingTimer(this);
                        this.pauseTimer = undefined;
                    }.bind(this));
                }.bind(this), pauseDuration * 1000);
                // self.stopSendingFramesTimer();
                // self.pauseSendingFramesTimer = setTimeout(function () {
                //     self.startSendingFramesTimer(self);
                //     self.pauseSendingFramesTimer = undefined;
                // }, pauseDuration * 1000);
                // // SendingFramesTimer
                // self.stopCapturingTimer();
                // self.pauseCapturingTimer = setTimeout(function () {
                //     self.startCapturingTimer(self);
                //     self.pauseCapturingTimer = undefined;
                // }, pauseDuration * 1000);
            };
            cameraCapture.prototype.stopPausingTimers = function (self) {
                if (webCam.helper.isDefined(self.pauseTimer)) {
                    console.log('clearing old pauseTimer...');
                    clearTimeout(self.pauseTimer);
                }
                // if (helper.isDefined(self.pauseCapturingTimer)) {
                //     console.log('clearing old pauseCapturingTimer...');
                //     clearTimeout(self.pauseCapturingTimer);
                // }
                // if (helper.isDefined(self.pauseSendingFramesTimer)) {
                //     console.log('clearing old pauseSendingFramesTimer...');
                //     clearTimeout(self.pauseSendingFramesTimer);
                // }
            };
            //#endregion
            //#region send captured frames Handling
            cameraCapture.prototype.sendNewFrame = function () {
                if (!this.checkCansendNewFrame() || this.capturedImagesQueue.length == 0)
                    return;
                // get last available one from the queue
                var frame = this.capturedImagesQueue.shift();
                this.lastSentRequestTime = new Date().getTime();
                this.sendingFramesService.send(frame, this.sendingDone);
            };
            cameraCapture.prototype.checkCansendNewFrame = function () {
                //  return !this.stopCapturing && this.sendingFramesService.pendingRequestsCount() < this.MAX_CONCURRENT_REQUESTS; // 5 for example
                return !this.stopCapturing;
            };
            cameraCapture.prototype.sendingDone = function () {
                // do nothing here for now
            };
            cameraCapture.prototype.handleResponse = function (self, response) {
                // ToDo: need to think more about handling response here
                if (!webCam.helper.isDefined(response)) {
                    return false;
                }
                var requiredAction = response.requiredAction;
                var message = response.message;
                var pauseDuration = response.pauseDuration;
                self.showMessage(message);
                switch (requiredAction) {
                    case retinaJs.WebcamRequiredAction[retinaJs.WebcamRequiredAction.StopCapturing]:
                        self.stopCapturing = true;
                        self.stopPausingTimers(self);
                        self.finish(true);
                        break;
                    case retinaJs.WebcamRequiredAction[retinaJs.WebcamRequiredAction.KeepCapturing]:
                        // Do nothing :)
                        break;
                    case retinaJs.WebcamRequiredAction[retinaJs.WebcamRequiredAction.PauseCapturing]:
                        self.pauseCaturing(pauseDuration);
                        break;
                }
            };
            cameraCapture.prototype.showMessage = function (msg) {
                if (msg != undefined && msg !== '') {
                    var cameraNotification = document.getElementById('camera-notification');
                    if (cameraNotification)
                        cameraNotification.setAttribute('class', 'visible');
                    var messageContainer = document.getElementById('messageContainer');
                    if (messageContainer) {
                        messageContainer.setAttribute('class', 'visible');
                        messageContainer.innerHTML = msg;
                    }
                }
            };
            cameraCapture.prototype.showDownCounter = function (self, startTime) {
                console.log('showDownCounter : ', startTime);
                if (startTime != undefined) {
                    if (webCam.helper.isDefined(self.downCounterTimer)) {
                        console.log('clearing old downCounterTimer...');
                        clearInterval(self.downCounterTimer);
                    }
                    var cameraNotification_1 = document.getElementById('camera-notification');
                    cameraNotification_1.setAttribute('class', 'visible');
                    var timeCounterContainer_1 = document.getElementById('timeCounterContainer');
                    var messageContainer_1 = document.getElementById('messageContainer');
                    timeCounterContainer_1.setAttribute('class', 'visible');
                    messageContainer_1.setAttribute('class', 'visible');
                    timeCounterContainer_1.innerHTML = startTime.toString();
                    self.downCounterTimer = setInterval(function () {
                        if (startTime >= 0) {
                            timeCounterContainer_1.innerHTML = startTime.toString();
                            startTime--;
                        }
                        else {
                            clearInterval(self.downCounterTimer);
                            timeCounterContainer_1.innerHTML = '';
                            messageContainer_1.innerHTML = '';
                            timeCounterContainer_1.setAttribute('class', 'hidden');
                            messageContainer_1.setAttribute('class', 'hidden');
                            cameraNotification_1.setAttribute('class', 'hidden');
                        }
                    }, 1000);
                }
            };
            //#endregion
            //#region common
            cameraCapture.prototype.stopStreaming = function () {
                this.removeCameraHtml();
                if (cameraCapture.strm) {
                    console.log('cameraCapture.strm is exist and stop it is in progress...');
                    // ToDo : MediaStream.stop() is deprecated and will soon be removed. Use MediaStreamTrack.stop() instead.
                    try {
                        cameraCapture.strm.stop();
                    }
                    catch (e) {
                        try {
                            //  cameraCapture.strm.getVideoTracks()[0].stop();
                            var tracks = cameraCapture.strm.getTracks();
                            var track = tracks[0]; // if only one media track
                            // ...
                            track.stop();
                        }
                        catch (ee) {
                            var tracks = cameraCapture.strm.getTracks();
                            var track = tracks[0]; // if only one media track
                            // ...
                            track.stop();
                        }
                    }
                    this.isCameraRun = false;
                }
            };
            cameraCapture.prototype.removeCameraHtml = function () {
                var containerId = this.options.containerId;
                document.getElementById(containerId).innerHTML = '';
            };
            cameraCapture.prototype.addCommonRequestParameters = function (formData) {
                //ToDo : check new contract to add needed parameters
                formData.append('SessionId', this.journeyId);
                // formData.append('EntryType', this.entryType);
                formData.append('OperationId', this.operationId);
                // formData.append('RequestMetadata', JSON.stringify(metadata));
                return FormData;
            };
            return cameraCapture;
        }());
        webCam.cameraCapture = cameraCapture;
    })(webCam = retinaJs.webCam || (retinaJs.webCam = {}));
})(retinaJs || (retinaJs = {}));
/// <reference path="../../baseimagecaptureservice.ts" />
/// <reference path="cameraCapture.ts" />
/// <reference path="../../types.ts" />
var retinaJs;
(function (retinaJs) {
    var webCam;
    (function (webCam) {
        var cameraCaptureService = (function (_super) {
            __extends(cameraCaptureService, _super);
            function cameraCaptureService(journeyId, options, isMediacreated) {
                if (isMediacreated === void 0) { isMediacreated = false; }
                console.log('** webCam | constructor **');
                _super.call(this, journeyId, retinaJs.mediaChannelType.Camera);
                this.initalizeCaptureSession(options, isMediacreated);
            }
            cameraCaptureService.prototype.init = function (options, isMediacreated) {
                if (isMediacreated === void 0) { isMediacreated = false; }
                return new Promise(function (resolve, reject) {
                    this.camera.init()
                        .then(function () {
                        if (options.autoRun)
                            setTimeout(function () { this.camera.start(); }.bind(this), 1000);
                        resolve(true);
                    }.bind(this))
                        .catch(function () {
                        reject(false);
                    });
                }.bind(this));
            };
            cameraCaptureService.prototype.sendMedia = function (options, isMediacreated) {
                console.log('** webCam | sendMedia implementaion **');
                var self = this;
                self.camera = new webCam.cameraCapture(options, this.journeyId, isMediacreated);
            };
            cameraCaptureService.prototype.start = function () {
                this.camera.start();
            };
            cameraCaptureService.prototype.finish = function (keepMedia) {
                this.camera.finish(keepMedia);
            };
            cameraCaptureService.prototype.subscribe = function (message, callback) {
                return this.camera.subscribe(message, callback);
            };
            cameraCaptureService.prototype.unSubscribe = function (message, subscriptionId) {
                this.camera.unSubscribe(message, subscriptionId);
            };
            cameraCaptureService.prototype.runTestResponse = function (response) {
                this.camera.runTestResponse(response);
            };
            cameraCaptureService.prototype.temp = function () {
            };
            return cameraCaptureService;
        }(retinaJs.baseImageCaptureService));
        webCam.cameraCaptureService = cameraCaptureService;
    })(webCam = retinaJs.webCam || (retinaJs.webCam = {}));
})(retinaJs || (retinaJs = {}));
/// <reference path="mediachanneltype/camera/cameraCaptureService.ts" />
/// <reference path="httpRequestService.ts" />
var retinaJs;
(function (retinaJs) {
    var retinaService = (function () {
        function retinaService(journeyId, containerId, apiCaptureChannelConfiguration, retinaSettings) {
            this.journeyId = undefined;
            this.containerId = undefined;
            this.currentImageCaptureService = undefined;
            this.deferred = undefined;
            this.retinaSettings = undefined;
            this.journeyId = journeyId;
            this.containerId = containerId;
            this.retinaSettings = retinaJs.helper.extend(retinaJs.helper.defaultRetinaSettings, retinaSettings); // maybe there is no need to assign result to retinaSettings
            this.prepareDefaultSettings(apiCaptureChannelConfiguration, retinaSettings.cortexApiPath);
        }
        retinaService.prototype.prepareDefaultSettings = function (apiCaptureChannelConfiguration, cortexApiPath) {
            this.defaultApiConfig = [apiCaptureChannelConfiguration];
            this.defaultRetinaSettings = this.retinaSettings;
        };
        retinaService.prototype.start = function () {
            if (!this.currentImageCaptureService)
                throw new Error("The current image capture service is undefined");
            this.currentImageCaptureService.start();
        };
        retinaService.prototype.subscribe = function (message, callback) {
            if (!this.currentImageCaptureService)
                throw new Error("The current image capture service is undefined");
            return this.currentImageCaptureService.subscribe(message, callback);
        };
        retinaService.prototype.unSubscribe = function (message, subscriptionId) {
            if (!this.currentImageCaptureService)
                throw new Error("The current image capture service is undefined");
            this.currentImageCaptureService.unSubscribe(message, subscriptionId);
        };
        retinaService.prototype.reset = function (journeyId) {
            console.group(" retinaService -  reset ");
            var self = this;
            this.journeyId = journeyId;
            var deferred = $.Deferred();
            self
                .create(this.containerId, this.retinaSettings)
                .then(function (imageCaptureServiceInstance) {
                self.currentImageCaptureService = imageCaptureServiceInstance;
                self.channelType = self.currentImageCaptureService.channelType;
                console.groupEnd(); //  retinaService - reset
                deferred.resolve();
            });
            return deferred.promise();
        };
        retinaService.prototype.terminate = function () {
            this.currentImageCaptureService.finish(false);
            this.currentImageCaptureService = undefined;
        };
        retinaService.prototype.runTestResponse = function (response) {
            if (!this.currentImageCaptureService)
                throw new Error("The current image capture service is undefined");
            this.currentImageCaptureService.runTestResponse(response);
        };
        retinaService.prototype.create = function (containerId, retinaSettings) {
            console.group(" retinaService - private create ");
            console.log("** retinaService | private create **");
            this.deferred = $.Deferred();
            //  Get Configuration for capture session
            // var ajaxSettings: JQueryAjaxSettings = {
            //   url: retinaSettings.cortexApiPath + "api/CaptureSessions/Config/" + this.journeyId
            // }
            // this.getCaptureSessionsConfigurations(ajaxSettings, retinaSettings);
            this.getConfigurationSuccess(this.defaultApiConfig, this.defaultRetinaSettings);
            return this.deferred.promise();
        };
        retinaService.prototype.getCaptureSessionsConfigurations = function (ajaxSettings, retinaSettings) {
            return retinaJs.httpRequestService.JQueryAjax(ajaxSettings)
                .then(function (data) {
                this.getConfigurationSuccess(data.result, retinaSettings);
            }.bind(this), this.getConfigurationField.bind(this));
        };
        retinaService.prototype.getConfigurationSuccess = function (apiConfig, retinaSettings) {
            console.log("** retinaService | getConfigurationSuccess **");
            if (apiConfig !== null && apiConfig.length > 0) {
                var mediaChannelInformations = void 0;
                mediaChannelInformations = this.toRetinaConfigurationMapper(apiConfig, retinaSettings);
                // ToDo: handle null returned value for getMedia 
                // like for example the configuration contain camera and it's not being able to open so the returned value is null
                this.getMedia(mediaChannelInformations)
                    .then(function (imageCaptureService) {
                    this.currentImageCaptureService = imageCaptureService;
                    console.groupEnd(); //  retinaService - private create
                    this.deferred.resolve(this.currentImageCaptureService);
                }.bind(this))
                    .catch(function (error) {
                    console.error("getMedia throw an error ", error);
                    this.deferred.reject("getMedia not able to return media ");
                });
            }
            else {
                console.error("Configuration From Vision Cortex is empty.");
                this.deferred.reject("Configuration From Vision Cortex is empty.");
            }
        };
        retinaService.prototype.toRetinaConfigurationMapper = function (config, retinaSettings) {
            var mediaChannelInformations = new Array();
            // Map  Api Configuration into  IMediaChannelInformation array
            for (var i = 0; i < config.length; i++) {
                var mediaChannelInfo = void 0;
                var currentChanneloptions = config[i].options;
                switch (config[i].channel) {
                    case retinaJs.mediaChannelType.Camera:
                        // case mediaChannelType[mediaChannelType.Camera]:
                        var currentChannelCameraoptions = currentChanneloptions;
                        var cameraOptions = {
                            containerId: this.containerId,
                            cortexApiPath: retinaSettings.cortexApiPath,
                            journeyId: this.journeyId,
                            imageQuality: currentChannelCameraoptions.jpegCompression,
                            captureStillImageOnly: currentChannelCameraoptions.captureStillImageOnly,
                            frameSubmitionDelay: currentChannelCameraoptions.frameSubmitionDelay,
                            autoRun: retinaSettings.autoRun
                        };
                        mediaChannelInfo = {
                            channelType: retinaJs.mediaChannelType.Camera,
                            options: cameraOptions
                        };
                        break;
                }
                if (mediaChannelInfo !== undefined)
                    mediaChannelInformations.push(mediaChannelInfo);
            }
            return mediaChannelInformations;
        };
        retinaService.prototype.getConfigurationField = function (jqXHR, textStatus, errorThrown) {
            console.error("error occours while trying to bring capture session configuration.");
            console.error(jqXHR);
            this.deferred.reject("error occours while trying to bring capture session configuration.");
        };
        retinaService.prototype.getMedia = function (mediaChannelInformations) {
            console.group(" retinaService -  getMedia ");
            console.log("** retinaService | getMedia **");
            // let media: IImageCaptureService;
            //  let isMediaReady: boolean = false;
            var isMediacreated = false;
            /**
             * if true means that there is an instance from 'imageCaptureService'
             * so will check if it's type same with next required media type
             * if yes then will not close/open media to not get flicker in the view
             */
            if (this.currentImageCaptureService !== undefined) {
                if (this.currentImageCaptureService.channelType == retinaJs.mediaChannelType[mediaChannelInformations[0].channelType]) {
                    // Stop All currentImageCaptureService Feature but keep it opened
                    this.currentImageCaptureService.finish(true);
                    isMediacreated = true;
                }
                else {
                    this.currentImageCaptureService.finish(false);
                }
            }
            console.groupEnd(); //  retinaService -  getMedia
            return this.createMediaInstance(mediaChannelInformations);
        };
        retinaService.prototype.createMediaInstance = function (mediaChannelInformations) {
            return new Promise(function (resolve, reject) {
                var mediaChannelInfo = mediaChannelInformations.shift();
                if (mediaChannelInfo === undefined)
                    reject();
                var isMediacreated = false;
                if (this.currentImageCaptureService !== undefined)
                    if (this.currentImageCaptureService.channelType == retinaJs.mediaChannelType[mediaChannelInfo.channelType])
                        isMediacreated = true;
                console.log("** retinaService | createMediaInstance **");
                switch (mediaChannelInfo.channelType) {
                    case retinaJs.mediaChannelType.Camera:
                        console.log("Factory => MediaChannelType.camera");
                        var cameraMediaReference_1;
                        var cameraOption = mediaChannelInfo.options;
                        // ToDo: study more this case if cameraCaptureService gives an error or nor done properly
                        // then it should be full down to create next media
                        try {
                            cameraMediaReference_1 = new retinaJs.webCam.cameraCaptureService(this.journeyId, cameraOption, isMediacreated);
                            return cameraMediaReference_1.init(cameraOption, isMediacreated)
                                .then(function () {
                                resolve(cameraMediaReference_1);
                            }.bind(this))
                                .catch(function () {
                                return this.createMediaInstance(mediaChannelInformations).then(function (imageCaptureService) {
                                    resolve(imageCaptureService);
                                }.bind(this))
                                    .catch(function (error) {
                                    reject();
                                });
                                // reject();
                            }.bind(this));
                        }
                        catch (ex) {
                            console.log("create cameraCaptureService instance failed TTTT  ", ex);
                            return this.createMediaInstance(mediaChannelInformations);
                        }
                }
                // return resultMediaReference;
            }.bind(this));
        };
        return retinaService;
    }());
    retinaJs.retinaService = retinaService;
})(retinaJs || (retinaJs = {}));
module.exports = retinaJs;
//# sourceMappingURL=retina.js.map


