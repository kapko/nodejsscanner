/*
 * Created by: IDScan @ 14-12-2015
 * Version 2.0.0
 */
function idScanCroppy($, options) {

		var defaults = {
			selection: {
				lineColor: '#000',
				highlightColor: '#f00',
				coordsTextColor: '#005EA5'
			},
			imageSrc: '',
			magnifierCanvasId: '',
			targetCanvasId: '',
			padding: 0,
			showCornersAlways: true
		};

		options = $.extend(true, {}, defaults, options);

		var $targetCanvas = $(options.targetCanvasId);
		var targetCanvasContext = $targetCanvas[0].getContext('2d');
		var $magnifier = $(options.magnifierCanvasId);
		var magctx = $magnifier[0] ? $magnifier[0].getContext('2d') : null;
		var imageSrc = options.imageSrc;

		var image;
		var workspace = {
			width: 0,
			height: 0,
			widthFactor: 0,
			heightFactor: 0,
			x: 0,
			y: 0
		};
		var mouseX, mouseY = 1;
		var selectionArea;
		var rotationDegrees = 0;
		var off = 10;
		var zs = 10;
		var magsz = off * zs;
		var mouseDragging = false;
		var isTouchDevice = 'ontouchstart' in document.documentElement;
		var cubeSize = isTouchDevice ? 9 : (options.showCornersAlways ? 6 : 0);
		var cubeDragAreaSize = isTouchDevice ? 13 : 10;

		var element = {
			width: 0,
			height: 0,
			x: 0,
			y: 0
		};

		var interval = 1000;

		var cursorDraggingIcon = 'grabbing';
		var cursorIcon = 'grab';

		this.init = function (selectionAreaPoints, areOriginalCoords) {
			// Load the source image
			image = new Image();
			image.onload = function () {

				setWorkspace();

				selectionAreaPoints = selectionAreaPoints && selectionAreaPoints.length > 0 ? selectionAreaPoints : null;
				setSelectionAreaValues(selectionAreaPoints, areOriginalCoords);

				drawScene();
			}

			image.src = imageSrc;

			setCursor(false);

			setEvents();
		}

		this.crop = function (elementContainerId) {
			var targetCanvElem = $targetCanvas.get(0);

			var tempCanvas = document.createElement("canvas");
			tempCanvas.width = targetCanvElem.width;
			tempCanvas.height = targetCanvElem.height;

			drawScene(true);

			var tCtx = tempCanvas.getContext("2d");
			drawPath(tCtx);
			tCtx.clip();
			tCtx.drawImage(targetCanvElem, 0, 0);
			tCtx.restore();
			drawScene();

			$(elementContainerId).empty();
			$(elementContainerId).append(tempCanvas);
		}

		this.getOriginalSelectionAreaPoints = function () {
			var points = [];
			var x, y;
			for (var i = 0; i < selectionArea.points.length; i++) {
				x = selectionArea.points[i][0];
				y = selectionArea.points[i][1];

				points.push(convertTo(true, x, y));
			}

			return [points, getFloat(rotationDegrees)];
		}

		this.getSelectionAreaPoints = function () {
			return [selectionArea.points, rotationDegrees];
		}

		this.rotate = function (degrees) {
			rotationDegrees = degrees;
			rotateCanvas(targetCanvasContext);
			drawSelectionArea();
		}

		function setWorkspace() {

			element.width = revTranslatePoint(revTranslatePoint($targetCanvas.width()));
			element.height = revTranslatePoint(revTranslatePoint($targetCanvas.height()));


			var iw = image.width;
			var ih = image.height;
			var iratio = iw / ih;
			var eratio = element.width / element.height;

			if (iratio > eratio) {
				workspace.width = element.width;
				workspace.height = (element.width / image.width) * image.height;
			} else if (eratio > iratio) {
				workspace.height = element.height;
				workspace.width = (element.height / image.height) * image.width;
			} else {
				workspace.height = element.height;
				workspace.width = element.width;
			}

			workspace.x = ((element.width - workspace.width) / 2) - (element.width / 2);
			workspace.y = ((element.height - workspace.height) / 2) - (element.height / 2);

			$targetCanvas.css('background', 'url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABGdBTUEAALGPC/xhBQAAADRJREFUOBFjnDdv3n8GPODBgwd4ZBkYmPDKEiE5asBgCEQWQvGsoKCANzJHo3EwRCPFsQAAK2QIm0OM5jYAAAAASUVORK5CYII=")');

			setInterval(function () {

				var wh = revTranslatePoint(revTranslatePoint($targetCanvas.height()));
				var ww = revTranslatePoint(revTranslatePoint($targetCanvas.width()));

				if (wh !== element.height || ww !== element.width) {
					setWorkspace();
					setSelectionAreaValues();
					drawScene();
				}

				if (selectionArea.getOffset() !== getCanvasOffset()) {
					selectionArea.setOffset(getCanvasOffset());
				}

			}, interval);

			var widthWithPadding = translatePoint(translatePoint(element.width));
			var heightWithPadding = translatePoint(translatePoint(element.height));

			//set factors
			workspace.widthFactor = (workspace.width / image.width);
			workspace.heightFactor = (workspace.height / image.height);

			$targetCanvas.attr('width', widthWithPadding);
			$targetCanvas.attr('height', heightWithPadding);

			if ($magnifier) {
				$magnifier.attr('width', magsz);
				$magnifier.attr('height', magsz);
			}
		}

		function setSelectionAreaValues(initialPoints, areOriginalCoords) {
			if (initialPoints) {
				selectionArea = new selectionAreaClass(initialPoints, areOriginalCoords);
			}
			else
				selectionArea = new selectionAreaClass(initSelectAreaPoints(workspace.width, workspace.height));


			selectionArea.setOffset(getCanvasOffset());
		}

		function setEvents() {
			var moveEvent, upEvent, downEvent;
			var moveEventName, upEventName, downEventName;
			if (!isTouchDevice) {
				moveEventName = "mousemove";
				moveEvent = mouseMove;

				upEventName = "mouseup";
				upEvent = pointerUpFunc;

				downEventName = "mousedown";
				downEvent = pointerDownFunc;
			} else {
				moveEventName = "touchmove";
				moveEvent = touchMove;

				upEventName = "touchend";
				upEvent = pointerUpFunc;

				downEventName = "touchstart";
				downEvent = pointerDownFunc;
			}

			$targetCanvas.bind(moveEventName, moveEvent);
			$targetCanvas.bind(upEventName, upEvent);
			$targetCanvas.bind(downEventName, downEvent);
		}

		function mouseMove(e) {
			e.preventDefault();

			moveCubes(e.pageX, e.pageY);
		}

		function touchMove(e) {
			e.preventDefault();

			var event = window.event;

			moveCubes(event.touches[0].pageX, event.touches[0].pageY);
		}

		function translatePoint(number) {
			return number + options.padding;
		}

		function revTranslatePoint(number) {
			return number - options.padding;
		}

		function pointerDownFunc(e) {
			e.preventDefault();

			for (var i = 0; i < selectionArea.points.length; i++) {
				if (selectionArea.hovering[i]) {
					mouseDragging = true;
					selectionArea.dragging[i] = true;

					setCursor(true);
				}
			}
		}

		function pointerUpFunc(e) {

			// Set all the drag statuses to false
			for (var i = 0; i < selectionArea.points.length; i++) {
				mouseDragging = false;
				selectionArea.dragging[i] = false;
				selectionArea.hovering[i] = false;

				setCursor(false);
			}

			// Clear the magnified view
			if (magctx)
				magctx.clearRect(0, 0, magsz, magsz);

			drawScene();
		}

		function moveCubes(xPos, yPos) {
			// Calculate the position of the mouse on the canvas
			mouseX = Math.floor(xPos - selectionArea.initCanvasLeft - 2);
			mouseY = Math.floor(yPos - selectionArea.initCanvasTop - 2);

			if (mouseX < translatePoint(workspace.x + (element.width / 2))) mouseX = translatePoint(workspace.x + (element.width / 2));
			if (mouseY < translatePoint(workspace.y + (element.height / 2))) mouseY = translatePoint(workspace.y + (element.height / 2));
			if (mouseX >= translatePoint((workspace.x + (element.width / 2)) + workspace.width)) mouseX = translatePoint((workspace.x + (element.width / 2)) + workspace.width);
			if (mouseY >= translatePoint((workspace.y + (element.height / 2)) + workspace.height)) mouseY = translatePoint((workspace.y + (element.height / 2)) + workspace.height);

			// Hovering over resize cubes
			if (selectionArea) {
				for (var i = 0; i < selectionArea.points.length; i++) {
					var x = selectionArea.points[i][0];
					var y = selectionArea.points[i][1];
					var csz = selectionArea.csizeh;
					selectionArea.hovering[i] =
						mouseX > x - csz && mouseX < x + csz &&
						mouseY > y - csz && mouseY < y + csz;

					if (isTouchDevice) {
						if (selectionArea.hovering[i])
							selectionArea.dragging[i] = selectionArea.hovering[i];

						if (selectionArea.dragging[i]) {
							selectionArea.points[i][0] = mouseX;
							selectionArea.points[i][1] = mouseY;
						}
					}
				}

				// In case of not touch screens
				if (!isTouchDevice) {
					for (var i = 0; i < selectionArea.points.length; i++) {
						if (selectionArea.dragging[i]) {
							selectionArea.points[i][0] = mouseX;
							selectionArea.points[i][1] = mouseY;
						}
					}
				}
			}
			drawScene();
		}

		function setCursor(isDragging) {
			if (isDragging)
				$targetCanvas.css('cursor', cursorDraggingIcon);
			else
				$targetCanvas.css('cursor', cursorIcon);
		}

		function getFloat(number) {
			return parseFloat(number.toFixed(3));
		}

		function drawPath(context) {
			context.beginPath();

			for (var i = 0; i < selectionArea.points.length; i++) {
				var x = parseInt(jQuery.trim(selectionArea.points[i][0]));
				var y = parseInt(jQuery.trim(selectionArea.points[i][1]));
				if (i == 0)
					context.moveTo(x, y);
				else
					context.lineTo(x, y);
			}

			context.closePath();
		}

		function rotateCanvas(context) {

			var canvas = context.canvas;

			context.clearRect(0, 0, canvas.width, canvas.height);

			// save the unrotated context of the canvas so we can restore it later
			// the alternative is to untranslate & unrotate after drawing
			context.save();

			var centerX = canvas.width / 2;
			var centerY = canvas.height / 2;

			// move to the center of the canvas
			context.translate(centerX, centerY);

			// rotate the canvas to the specified degrees
			context.rotate(rotationDegrees * Math.PI / 180);

			// draw the image
			// since the context is rotated, the image will be rotated also
			context.drawImage(image, workspace.x, workspace.y, workspace.width, workspace.height);
			// we’re done with the rotating so restore the unrotated context
			context.restore();
		}

		function initSelectAreaPoints(width, height) {
			// var x1 = translatePoint(0);
			// var y1 = translatePoint(0);
			var x1 = translatePoint(workspace.x + (element.width / 2));
			var y1 = translatePoint(workspace.y + (element.height / 2));
			var x2 = translatePoint(x1 + revTranslatePoint(workspace.width));
			var y2 = translatePoint(y1 + revTranslatePoint(workspace.height));

			return [[x1, y1], [x1, y2], [x2, y2], [x2, y1]];
		}

		function selectionAreaClass(pts, areOriginalCoords) {
			// Our (usually 4) corners
			if (areOriginalCoords) {
				for (var i = 0; i < pts.length; i++) {
					pts[i] = convertTo(false, pts[i][0], pts[i][1]);
				}
			}

			this.points = pts;

			this.canvasOffset;

			// Some constants
			this.csize = cubeSize; // Resize cubes size
			this.csizeh = cubeDragAreaSize; // Grip cubes size (on hover)
			this.highlight = options.selection.highlightColor;
			this.linecolor = options.selection.lineColor;
			this.textcolor = options.selection.coordsTextColor;
			// Status of whether the mouse is hovering over or dragging the
			// corners
			this.hovering = [false, false, false, false]; // Hover status
			this.dragging = [false, false, false, false]; // Drag status
		}

		selectionAreaClass.prototype.setOffset = function(canvasOffset) {
			this.canvasOffset = canvasOffset;
			this.initCanvasLeft = canvasOffset.left;
			this.initCanvasTop = canvasOffset.top;
		}

		selectionAreaClass.prototype.getOffset = function() {
			return this.canvasOffset;
		}

		function getCanvasOffset() {
			return $targetCanvas.offset();
		}

		function drawSelectionArea() {

			if (!selectionArea)
				return;

			var drawn = false;
			var draggedCubeFound = !mouseDragging;

			// Draw grip cubes
			for (var i = 0; i < selectionArea.points.length; i++) {
				targetCanvasContext.fillStyle =
					selectionArea.dragging[i] ? selectionArea.highlight : selectionArea.textcolor;

				if (selectionArea.dragging[i]) {

					draggedCubeFound = true;

					var x = selectionArea.points[i][0];
					var y = selectionArea.points[i][1];
					var sz = selectionArea.csizeh;

					drawMagnifier(x, y);

					if (!drawn) {
						drawLineBetweenCubes();
						drawn = true;
					}

					// First draw the grip cube
					targetCanvasContext.strokeStyle = selectionArea.highlight;
					targetCanvasContext.strokeRect(x - sz, y - sz, sz * 2, sz * 2);
					targetCanvasContext.strokeStyle = selectionArea.linecolor;
				} else {
					if (draggedCubeFound && !drawn) {
						drawLineBetweenCubes();
						drawn = true;
					}

					// Draw filled cubes for the grips, larger if hovered over
					var csz = selectionArea.hovering[i] ? selectionArea.csizeh : selectionArea.csize;
					targetCanvasContext.fillRect(selectionArea.points[i][0] - csz, selectionArea.points[i][1] - csz, csz * 2, csz * 2);
				}

				// drawCoordinatesText(i);
			}
		}

		function drawMagnifier(x, y) {
			if ($magnifier && magctx) {
				// Next we'll draw a magnified portion of the part of the
				// image under the cursor, with cross-hairs
				magctx.clearRect(0, 0, magsz, magsz);

				//set factors
				var targetCanvas = $targetCanvas[0];

				var xpos = x < off ? 0 : x - off;
				var ypos = y < off ? 0 : y - off;
				var fromRight = targetCanvas.width - x;
				var fromBottom = targetCanvas.height - y;
				var wid = fromRight <= off ? off + fromRight - 1 : off * 2;
				var hgt = fromBottom <= off ? off + fromBottom - 1 : off * 2;
				var fac = 1 / (off * 2);

				magctx.drawImage(
					$targetCanvas[0], xpos, ypos, wid, hgt, (xpos - (x - off)) * zs / 2, (ypos - (y - off)) * zs / 2,
					Math.floor(wid * fac * magsz),
					Math.floor(hgt * fac * magsz)
				);

				// Vertical
				magctx.beginPath();
				magctx.moveTo(magsz / 2, 0);
				magctx.lineTo(magsz / 2, magsz);
				magctx.closePath();
				magctx.stroke();

				// Horizontal

				magctx.beginPath();
				magctx.moveTo(0, magsz / 2);
				magctx.lineTo(magsz, magsz / 2);
				magctx.closePath();
				magctx.stroke();
			}
		}

		function drawLineBetweenCubes() {
			// Draw lines between the corners
			targetCanvasContext.strokeStyle = selectionArea.linecolor;
			targetCanvasContext.lineWidth = 2;

			targetCanvasContext.beginPath();
			targetCanvasContext.moveTo(selectionArea.points[0][0], selectionArea.points[0][1]);
			for (var j = 1; j < selectionArea.points.length; j++) {
				targetCanvasContext.lineTo(selectionArea.points[j][0], selectionArea.points[j][1]);
			}
			targetCanvasContext.lineTo(selectionArea.points[0][0], selectionArea.points[0][1]);
			targetCanvasContext.closePath();
			targetCanvasContext.stroke();
		}

		function drawCoordinatesText(i) {

			if (options.showCornersAlways || (!options.showCornersAlways && selectionArea.hovering[i])) {
				// Now we'll draw some text with the coordinate information in
				// them at an appropriate point for each of the corners

				// Make the text centered (vertically)

				targetCanvasContext.textBaseline = 'middle';
				targetCanvasContext.textAlign = 'left';

				// We'll work out X and Y offsets to make sure the text looks
				// OK and doesn't try to leave the canvas

				var xoff = -2 * selectionArea.csizeh;
				var yoff = (i > 0 && i < 3 ? 2 : -2) * selectionArea.csizeh;

				// If at the bottom, reverse the Y offset

				if (
					selectionArea.points[i][1] + yoff > targetCanvasContext.canvas.height ||
					selectionArea.points[i][1] + yoff < 0
				)
					yoff = -yoff;

				// If at the left, make the text appear right at X = 0

				if (
					selectionArea.points[i][0] + xoff < 0
				)
					xoff = -selectionArea.points[i][0];

				// If nearly at the right, make the text right-justified and set
				// the location to be at the right margin

				if (
					selectionArea.points[i][0] + xoff > targetCanvasContext.canvas.width - (4 * selectionArea.csizeh)
				) {
					targetCanvasContext.textAlign = 'right';
					xoff = $targetCanvas[0].width - selectionArea.points[i][0];
				}

				// And draw the coordinate text

				targetCanvasContext.fillText(
					selectionArea.points[i][0] + ',' + selectionArea.points[i][1],
					selectionArea.points[i][0] + xoff,
					selectionArea.points[i][1] + yoff
				);
			}
		}

		function drawScene(dontDrawSquares) {

			rotateCanvas(targetCanvasContext);

			if (!dontDrawSquares)
				drawSelectionArea();
		}

		function convertTo(original, x, y) {
			var xGap = translatePoint((element.width - workspace.width) / 2);
			var yGap = translatePoint((element.height - workspace.height) / 2);

			if (original === true) {
				var xOrg = getFloat((x - xGap) / workspace.widthFactor);
				var yOrg = getFloat((y - yGap) / workspace.heightFactor);

				return [xOrg, yOrg];
			} else {
				var xCan = getFloat((x * workspace.widthFactor) + xGap);
				var yCan = getFloat((y * workspace.heightFactor) + yGap);

				return [xCan, yCan];
			}
		}
	}
